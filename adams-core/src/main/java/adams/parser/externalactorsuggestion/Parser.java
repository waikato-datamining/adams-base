
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package adams.parser.externalactorsuggestion;

import adams.core.classmanager.ClassManager;
import adams.flow.core.AbstractActor;
import adams.flow.core.Actor;
import adams.flow.core.ActorHandler;
import adams.flow.core.ActorUtils;
import adams.flow.core.Compatibility;
import adams.flow.core.InputConsumer;
import adams.flow.core.OutputProducer;
import adams.gui.flow.tree.Node;
import adams.parser.ParserHelper;
import nz.ac.waikato.cms.locator.ClassLocator;

import java.util.logging.Level;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\061\000\002\002\004\000\002\002\004\000\002\002" +
    "\003\000\002\004\006\000\002\005\005\000\002\005\003" +
    "\000\002\005\003\000\002\005\003\000\002\005\005\000" +
    "\002\005\005\000\002\005\004\000\002\005\003\000\002" +
    "\005\003\000\002\005\005\000\002\005\005\000\002\005" +
    "\005\000\002\005\005\000\002\005\005\000\002\005\005" +
    "\000\002\005\005\000\002\005\005\000\002\005\004\000" +
    "\002\005\004\000\002\005\004\000\002\005\004\000\002" +
    "\005\004\000\002\005\004\000\002\005\004\000\002\005" +
    "\004\000\002\005\004\000\002\005\004\000\002\005\005" +
    "\000\002\005\005\000\002\005\005\000\002\005\005\000" +
    "\002\005\005\000\002\005\005\000\002\005\005\000\002" +
    "\005\005\000\002\005\005\000\002\005\005\000\002\005" +
    "\005\000\002\005\005\000\002\005\005\000\002\005\005" +
    "\000\002\005\005\000\002\006\003\000\002\007\003\000" +
    "\002\007\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\116\000\004\033\006\001\002\000\004\002\120\001" +
    "\002\000\004\002\uffff\001\002\000\042\006\023\007\010" +
    "\010\020\011\017\012\021\013\011\014\024\015\012\016" +
    "\007\026\014\027\013\030\016\031\026\037\015\040\022" +
    "\043\025\001\002\000\012\032\ufff5\034\ufff5\035\ufff5\036" +
    "\ufff5\001\002\000\006\041\114\042\113\001\002\000\004" +
    "\041\105\001\002\000\012\032\ufff6\034\ufff6\035\ufff6\036" +
    "\ufff6\001\002\000\012\032\ufffb\034\ufffb\035\ufffb\036\ufffb" +
    "\001\002\000\012\032\ufffc\034\ufffc\035\ufffc\036\ufffc\001" +
    "\002\000\014\004\047\022\102\023\103\024\104\025\100" +
    "\001\002\000\012\032\ufffa\034\ufffa\035\ufffa\036\ufffa\001" +
    "\002\000\004\021\076\001\002\000\004\020\074\001\002" +
    "\000\004\041\066\001\002\000\014\004\047\022\063\023" +
    "\064\024\065\025\061\001\002\000\010\017\053\041\054" +
    "\042\052\001\002\000\004\041\043\001\002\000\042\006" +
    "\023\007\010\010\020\011\017\012\021\013\011\014\024" +
    "\015\012\016\007\026\014\027\013\030\016\031\026\037" +
    "\015\040\022\043\025\001\002\000\042\006\023\007\010" +
    "\010\020\011\017\012\021\013\011\014\024\015\012\016" +
    "\007\026\014\027\013\030\016\031\026\037\015\040\022" +
    "\043\025\001\002\000\010\034\031\035\030\036\032\001" +
    "\002\000\042\006\023\007\010\010\020\011\017\012\021" +
    "\013\011\014\024\015\012\016\007\026\014\027\013\030" +
    "\016\031\026\037\015\040\022\043\025\001\002\000\006" +
    "\004\035\005\036\001\002\000\042\006\023\007\010\010" +
    "\020\011\017\012\021\013\011\014\024\015\012\016\007" +
    "\026\014\027\013\030\016\031\026\037\015\040\022\043" +
    "\025\001\002\000\012\032\ufff8\034\ufff8\035\ufff8\036\ufff8" +
    "\001\002\000\004\002\ufffe\001\002\000\004\002\uffd2\001" +
    "\002\000\004\002\uffd1\001\002\000\012\032\ufff9\034\ufff9" +
    "\035\ufff9\036\ufff9\001\002\000\010\032\041\035\030\036" +
    "\032\001\002\000\012\032\ufffd\034\ufffd\035\ufffd\036\ufffd" +
    "\001\002\000\012\032\ufff7\034\ufff7\035\ufff7\036\ufff7\001" +
    "\002\000\014\004\047\022\046\023\050\024\051\025\044" +
    "\001\002\000\012\032\uffd4\034\uffd4\035\uffd4\036\uffd4\001" +
    "\002\000\012\032\uffd8\034\uffd8\035\uffd8\036\uffd8\001\002" +
    "\000\012\032\uffd7\034\uffd7\035\uffd7\036\uffd7\001\002\000" +
    "\012\032\uffd3\034\uffd3\035\uffd3\036\uffd3\001\002\000\012" +
    "\032\uffd6\034\uffd6\035\uffd6\036\uffd6\001\002\000\012\032" +
    "\uffd5\034\uffd5\035\uffd5\036\uffd5\001\002\000\004\004\047" +
    "\001\002\000\006\022\056\023\057\001\002\000\004\004" +
    "\047\001\002\000\012\032\ufff4\034\ufff4\035\ufff4\036\ufff4" +
    "\001\002\000\012\032\ufff2\034\ufff2\035\ufff2\036\ufff2\001" +
    "\002\000\012\032\ufff1\034\ufff1\035\ufff1\036\ufff1\001\002" +
    "\000\012\032\ufff3\034\ufff3\035\ufff3\036\ufff3\001\002\000" +
    "\012\032\uffe4\034\uffe4\035\uffe4\036\uffe4\001\002\000\012" +
    "\032\uffe3\034\uffe3\035\uffe3\036\uffe3\001\002\000\012\032" +
    "\uffe7\034\uffe7\035\uffe7\036\uffe7\001\002\000\012\032\uffe6" +
    "\034\uffe6\035\uffe6\036\uffe6\001\002\000\012\032\uffe5\034" +
    "\uffe5\035\uffe5\036\uffe5\001\002\000\014\004\047\022\071" +
    "\023\072\024\073\025\067\001\002\000\012\032\uffde\034" +
    "\uffde\035\uffde\036\uffde\001\002\000\012\032\uffe2\034\uffe2" +
    "\035\uffe2\036\uffe2\001\002\000\012\032\uffe1\034\uffe1\035" +
    "\uffe1\036\uffe1\001\002\000\012\032\uffe0\034\uffe0\035\uffe0" +
    "\036\uffe0\001\002\000\012\032\uffdf\034\uffdf\035\uffdf\036" +
    "\uffdf\001\002\000\004\004\047\001\002\000\012\032\uffee" +
    "\034\uffee\035\uffee\036\uffee\001\002\000\004\004\047\001" +
    "\002\000\012\032\uffed\034\uffed\035\uffed\036\uffed\001\002" +
    "\000\012\032\uffe9\034\uffe9\035\uffe9\036\uffe9\001\002\000" +
    "\012\032\uffe8\034\uffe8\035\uffe8\036\uffe8\001\002\000\012" +
    "\032\uffec\034\uffec\035\uffec\036\uffec\001\002\000\012\032" +
    "\uffeb\034\uffeb\035\uffeb\036\uffeb\001\002\000\012\032\uffea" +
    "\034\uffea\035\uffea\036\uffea\001\002\000\014\004\047\022" +
    "\110\023\111\024\112\025\106\001\002\000\012\032\uffd9" +
    "\034\uffd9\035\uffd9\036\uffd9\001\002\000\012\032\uffdd\034" +
    "\uffdd\035\uffdd\036\uffdd\001\002\000\012\032\uffdc\034\uffdc" +
    "\035\uffdc\036\uffdc\001\002\000\012\032\uffdb\034\uffdb\035" +
    "\uffdb\036\uffdb\001\002\000\012\032\uffda\034\uffda\035\uffda" +
    "\036\uffda\001\002\000\004\004\047\001\002\000\004\004" +
    "\047\001\002\000\012\032\ufff0\034\ufff0\035\ufff0\036\ufff0" +
    "\001\002\000\012\032\uffef\034\uffef\035\uffef\036\uffef\001" +
    "\002\000\004\002\001\001\002\000\004\002\000\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\116\000\006\002\003\004\004\001\001\000\002\001" +
    "\001\000\004\003\116\001\001\000\004\005\026\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\006\100\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\006\061\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\005\041\001" +
    "\001\000\004\005\037\001\001\000\002\001\001\000\004" +
    "\005\036\001\001\000\004\007\033\001\001\000\004\005" +
    "\032\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\006\044" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\006\057\001\001\000\002\001\001\000\004\006" +
    "\054\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\006\067\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\006\074\001\001\000\002\001\001\000\004\006" +
    "\076\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\006\106\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\006\115\001\001\000\004\006\114\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



  /** the helper. */
  protected ParserHelper m_Helper = new ParserHelper();

  /** for storing the result of the expression. */
  protected Actor m_Result = null;

  /** the parent of the proposed actor. */
  protected Actor m_Parent = null;

  /** the parent node of the proposed actor. */
  protected Node m_ParentNode = null;

  /** the last parent used. */
  protected Actor m_LastParent = null;

  /** the last parent node used. */
  protected Node m_LastParentNode = null;

  /** the position to add the proposed actor at. */
  protected Integer m_Position = null;

  /** all the current actors in which to insert/add to the proposed actor. */
  protected Actor[] m_Actors = null;

  /** all the current nodes in which to insert/add to the proposed actor. */
  protected Node[] m_ActorNodes = null;

  /** for checking compatibility. */
  protected Compatibility m_Compatibility = new Compatibility(true);

  /**
   * Returns the parser helper.
   *
   * @return the helper
   */
  public ParserHelper getHelper() {
    return m_Helper;
  }

  /**
   * Sets the result of the evaluation.
   *
   * @param value the result
   */
  public void setResult(Actor value) {
    m_Result = value;
  }

  /**
   * Returns the result of the evaluation.
   *
   * @return the result
   */
  public Actor getResult() {
    return m_Result;
  }

  /**
   * Sets the parent of the proposed actor.
   *
   * @param value the actor
   */
  public void setParent(Actor value) {
    m_Parent     = value;
    m_LastParent = value;
  }

  /**
   * Returns the parent of the proposed actor.
   *
   * @return the parent
   */
  public Actor getParent() {
    return m_Parent;
  }

  /**
   * Sets the parent node of the proposed actor.
   *
   * @param value the actor
   */
  public void setParentNode(Node value) {
    m_ParentNode     = value;
    m_LastParentNode = value;
  }

  /**
   * Returns the parent node of the proposed actor.
   *
   * @return the parent
   */
  public Node getParentNode() {
    return m_ParentNode;
  }

  /**
   * Sets the position of the proposed actor.
   *
   * @param value the position
   */
  public void setPosition(Integer value) {
    m_Position = value;
  }

  /**
   * Returns the position of the proposed actor.
   *
   * @return the position
   */
  public Integer getPosition() {
    return m_Position;
  }

  /**
   * Sets the actors in which to insert the proposed actor.
   *
   * @param value the actors
   */
  public void setActors(Actor[] value) {
    m_Actors = value;
  }

  /**
   * Returns the actors in which to insert the proposed actor.
   *
   * @return the actors
   */
  public Actor[] getActors() {
    return m_Actors;
  }

  /**
   * Sets the nodes in which to insert the proposed actor.
   *
   * @param value the nodes
   */
  public void setActorNodes(Node[] value) {
    m_ActorNodes = value;
  }

  /**
   * Returns the nodes in which to insert the proposed actor.
   *
   * @return the nodes
   */
  public Node[] getActorNodes() {
    return m_ActorNodes;
  }

  /**
   * Returns whether the proposed actor will get added at the first position.
   *
   * @return true if the actor gets added at the first position
   */
  public Boolean isFirst() {
    return (m_Position == 0);
  }

  /**
   * Returns whether the proposed actor will get added at the last position.
   *
   * @return true if the actor gets added at the last position
   */
  public Boolean isLast() {
    return (m_Position >= m_Actors.length);
  }

  /**
   * Checks whether the actor will get added before or after a standalone
   * actor.
   *
   * @param before whether the actor gets added before or after
   * @return true if the actor gets added before/after a standalone one
   */
  public Boolean isStandalone(boolean before) {
    boolean 	result;

    result = false;

    if (before) {
      if (m_Position + 1 < m_Actors.length) {
        result = (ActorUtils.isStandalone(m_Actors[m_Position + 1]));
      }
    }
    else {
      if (m_Position > 0) {
        result = (ActorUtils.isStandalone(m_Actors[m_Position - 1]));
      }
    }

    return result;
  }

  /**
   * Checks whether the current actor is a standalone actor.
   * Returns false for current actor (= 0) if more than one actor selected.
   *
   * @param index 0 for current, -1 for first, +1 for last
   * @return true if a standalone
   */
  public Boolean isStandalone(int index) {
    if (index == 0)
      return (m_Actors.length == 1) && (ActorUtils.isStandalone(m_Actors[m_Position]));
    else if (index == -1)
      return (ActorUtils.isStandalone(m_Actors[0]));
    else
      return (ActorUtils.isStandalone(m_Actors[m_Actors.length - 1]));
  }

  /**
   * Checks whether the actor will get added before or after a source
   * actor.
   *
   * @param before whether the actor gets added before or after
   * @return true if the actor gets added before/after a source one
   */
  public Boolean isSource(boolean before) {
    boolean 	result;

    result = false;

    if (before) {
      if (m_Position + 1 < m_Actors.length) {
        result = (ActorUtils.isSource(m_Actors[m_Position + 1]));
      }
    }
    else {
      if (m_Position > 0) {
        result = (ActorUtils.isSource(m_Actors[m_Position - 1]));
      }
    }

    return result;
  }

  /**
   * Checks whether the current actor is a source actor.
   * Returns false for current actor (= 0) if more than one actor selected.
   *
   * @param index 0 for current, -1 for first, +1 for last
   * @return true if a source
   */
  public Boolean isSource(int index) {
    if (index == 0)
      return (m_Actors.length == 1) && (ActorUtils.isSource(m_Actors[m_Position]));
    else if (index == -1)
      return (ActorUtils.isSource(m_Actors[0]));
    else
      return (ActorUtils.isSource(m_Actors[m_Actors.length - 1]));
  }

  /**
   * Checks whether the actor will get added before or after a transformer
   * actor.
   *
   * @param before whether the actor gets added before or after
   * @return true if the actor gets added before/after a transformer one
   */
  public Boolean isTransformer(boolean before) {
    boolean 	result;

    result = false;

    if (before) {
      if (m_Position + 1 < m_Actors.length) {
        result = (ActorUtils.isTransformer(m_Actors[m_Position + 1]));
      }
    }
    else {
      if (m_Position > 0) {
        result = (ActorUtils.isTransformer(m_Actors[m_Position - 1]));
      }
    }

    return result;
  }

  /**
   * Checks whether the current actor is a transformer actor.
   * Returns false for current actor (= 0) if more than one actor selected.
   *
   * @param index 0 for current, -1 for first, +1 for last
   * @return true if a transformer
   */
  public Boolean isTransformer(int index) {
    if (index == 0)
      return (m_Actors.length == 1) && (ActorUtils.isTransformer(m_Actors[m_Position]));
    else if (index == -1)
      return (ActorUtils.isTransformer(m_Actors[0]));
    else
      return (ActorUtils.isTransformer(m_Actors[m_Actors.length - 1]));
  }

  /**
   * Checks whether the actor will get added before or after a sink
   * actor.
   *
   * @param before whether the actor gets added before or after
   * @return true if the actor gets added before/after a sink one
   */
  public Boolean isSink(boolean before) {
    boolean 	result;

    result = false;

    if (before) {
      if (m_Position + 1 < m_Actors.length) {
        result = (ActorUtils.isSink(m_Actors[m_Position + 1]));
      }
    }
    else {
      if (m_Position > 0) {
        result = (ActorUtils.isSink(m_Actors[m_Position - 1]));
      }
    }

    return result;
  }

  /**
   * Checks whether the current actor is a sink actor.
   * Returns false for current actor (= 0) if more than one actor selected.
   *
   * @param index 0 for current, -1 for first, +1 for last
   * @return true if a sink
   */
  public Boolean isSink(int index) {
    if (index == 0)
      return (m_Actors.length == 1) && (ActorUtils.isSink(m_Actors[m_Position]));
    else if (index == -1)
      return (ActorUtils.isSink(m_Actors[0]));
    else
      return (ActorUtils.isSink(m_Actors[m_Actors.length - 1]));
  }

  /**
   * Checks whether the actor will get added before or after a specific
   * actor (exact classname or interface classname).
   *
   * @param before whether the actor gets added before or after
   * @param classname the name of the actor (or interface) to check against
   * @return true if the actor gets added before/after a specific one
   */
  public Boolean isClassname(boolean before, String classname) {
    boolean 	result;

    result = false;

    if (before) {
      if (m_Position + 1 < m_Actors.length) {
        result =    m_Actors[m_Position + 1].getClass().getName().equals(classname)
                 || ClassLocator.hasInterface(classname, m_Actors[m_Position + 1].getClass().getName());
      }
    }
    else {
      if (m_Position > 0) {
        result =    m_Actors[m_Position - 1].getClass().getName().equals(classname)
                 || ClassLocator.hasInterface(classname, m_Actors[m_Position - 1].getClass().getName());
      }
    }

    return result;
  }

  /**
   * Checks whether the current actor (single selection) is of the superclass
   * or interface.
   * Returns false for current actor (= 0) if more than one actor selected.
   *
   * @param index 0 for current, -1 for first, +1 for last
   * @param classname the name of the actor (or interface) to check against
   * @return true if the actor gets added before/after a specific one
   */
  public Boolean isClassname(int index, String classname) {
    if (index == 0)
      return (m_Actors.length == 1) && ClassLocator.matches(classname, m_Actors[m_Position].getClass().getName());
    else if (index == -1)
      return ClassLocator.matches(classname, m_Actors[0].getClass().getName());
    else
      return ClassLocator.matches(classname, m_Actors[m_Actors.length - 1].getClass().getName());
  }

  /**
   * Checks whether the parent is the specified classname.
   *
   * @param classname the class that parent must be
   * @param exact whether to perform exact classname matching (or just an instance of)
   * @param anyParent if any parent in the node hierarchy is tested
   * @return true if it is a match
   */
  public Boolean checkParent(String classname, boolean exact, boolean anyParent) {
    Node   parent;

    if (anyParent) {
      parent = getParentNode();
      while (parent != null) {
        if (exact) {
          if (parent.getActor().getClass().getName().equals(classname)) {
            m_LastParentNode = parent;
            m_LastParent     = parent.getActor();
            return true;
          }
        }
        else {
          if (   ClassLocator.getSingleton().isSubclass(classname, parent.getActor().getClass().getName())
              || ClassLocator.getSingleton().hasInterface(classname, parent.getActor().getClass().getName()) ) {
            m_LastParentNode = parent;
            m_LastParent     = parent.getActor();
            return true;
          }
        }

        parent = (Node) parent.getParent();
      }
    }
    else {
      if (exact) {
        if (getParent().getClass().getName().equals(classname)) {
          m_LastParentNode = getParentNode();
          m_LastParent     = getParent();
          return true;
        }
      }
      else {
        if (    ClassLocator.getSingleton().isSubclass(classname, getParent().getClass().getName())
             || ClassLocator.getSingleton().hasInterface(classname, getParent().getClass().getName()) ) {
          m_LastParentNode = getParentNode();
          m_LastParent     = getParent();
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Checks whether the preceding actor generates the specified class.
   *
   * @param classname the class that the preceding actor must generate
   * @return true if the preceding actor generates the specified class
   */
  public Boolean precedingGenerates(String classname) {
    Class           cls;

    if (m_Position == 0)
      return false;

    try {
      cls = ClassManager.getSingleton().forName(classname);
    }
    catch (Exception e) {
      getHelper().getLogger().log(Level.SEVERE, "ActorSuggestion (preceding generates): Failed to instantiate class '" + classname + "'!", e);
      return false;
    }

    if (!(m_Actors[m_Position - 1] instanceof OutputProducer))
      return false;

    return (m_Compatibility.isCompatible(((OutputProducer) m_Actors[m_Position - 1]).generates(), new Class[]{cls}));
  }

  /**
   * Checks whether the following actor accepts the specified class.
   *
   * @param classname the class that the following actor must accept
   * @return true if the following actor accepts the specified class
   */
  public Boolean followingAccepts(String classname) {
    Class           cls;

    if (m_Position >= m_Actors.length - 1)
      return false;

    try {
      cls = ClassManager.getSingleton().forName(classname);
    }
    catch (Exception e) {
      getHelper().getLogger().log(Level.SEVERE, "ActorSuggestion (following accepts): Failed to instantiate class '" + classname + "'!", e);
      return false;
    }

    if (!(m_Actors[m_Position + 1] instanceof InputConsumer))
      return false;

    return (m_Compatibility.isCompatible(new Class[]{cls}, ((InputConsumer) m_Actors[m_Position + 1]).accepts()));
  }

  /**
   * Processes the commandline and fills in placeholders:
   * classname: ${PARENT.CLASS}, ${LASTPARENT.CLASS}, ${PRECEDING.CLASS}, ${FOLLOWING.CLASS}
   * actor's name: ${PARENT.NAME}, ${LASTPARENT.NAME}, ${PRECEDING.NAME}, ${FOLLOWING.NAME}
   * actor's full name: ${PARENT.FULL}, ${LASTPARENT.FULL}, ${PRECEDING.FULL}, ${FOLLOWING.FULL}
   *
   * @param cmdline the commandline to process
   * @return the fullname of the specified actor or empty string if not available
   * @see #m_LastParent
   * @see #m_LastParentNode
   */
  public String insertPlaceholders(String cmdline) {
    String result;

    result = cmdline;

    // classname
    if (result.contains("${PARENT.CLASS}"))
      result = result.replace("${PARENT.CLASS}", m_Parent.getClass().getName());
    if (result.contains("${LASTPARENT.CLASS}"))
      result = result.replace("${LASTPARENT.CLASS}", m_LastParent.getClass().getName());
    if (result.contains("${PRECEDING.CLASS}") && (m_Position > 0))
      result = result.replace("${PRECEDING.CLASS}", m_Actors[m_Position - 1].getClass().getName());
    if (result.contains("${FOLLOWING.CLASS}") && (m_Position < m_Actors.length - 1))
      result = result.replace("${FOLLOWING.CLASS}", m_Actors[m_Position + 1].getClass().getName());

    // name
    if (result.contains("${PARENT.NAME}"))
      result = result.replace("${PARENT.NAME}", m_Parent.getName());
    if (result.contains("${LASTPARENT.NAME}"))
      result = result.replace("${LASTPARENT.NAME}", m_LastParent.getName());
    if (result.contains("${PRECEDING.NAME}") && (m_Position > 0))
      result = result.replace("${PRECEDING.NAME}", m_Actors[m_Position - 1].getName());
    if (result.contains("${FOLLOWING.NAME}") && (m_Position < m_Actors.length - 1))
      result = result.replace("${FOLLOWING.NAME}", m_Actors[m_Position + 1].getName());

    // fullname
    if (result.contains("${PARENT.FULL}"))
      result = result.replace("${PARENT.FULL}", (m_ParentNode != null) ? m_ParentNode.getFullName() : m_Parent.getFullName());
    if (result.contains("${LASTPARENT.FULL}"))
      result = result.replace("${LASTPARENT.FULL}", (m_LastParentNode != null) ? m_LastParentNode.getFullName() : m_LastParent.getFullName());
    if (result.contains("${PRECEDING.FULL}") && (m_Position > 0))
      result = result.replace("${PRECEDING.FULL}", (m_ActorNodes != null) ? m_ActorNodes[m_Position - 1].getFullName() : m_Actors[m_Position - 1].getFullName());
    if (result.contains("${FOLLOWING.FULL}") && (m_Position < m_Actors.length - 1))
      result = result.replace("${FOLLOWING.FULL}", (m_ActorNodes != null) ? m_ActorNodes[m_Position + 1].getFullName() : m_Actors[m_Position + 1].getFullName());

    return result;
  }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // rule ::= expr expr_list 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rule",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= rule EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // rule ::= expr 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rule",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // expr ::= IF boolexpr THEN cmdexpr 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Boolean e = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                  if (e && !c.isEmpty())
                    parser.setResult(AbstractActor.forCommandLine(parser.insertPlaceholders(c)));
                  else
                    parser.setResult(null);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // boolexpr ::= LPAREN boolexpr RPAREN 
            {
              Boolean RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = b; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // boolexpr ::= BOOLEAN 
            {
              Boolean RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = b; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // boolexpr ::= TRUE 
            {
              Boolean RESULT =null;
		 RESULT = true; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // boolexpr ::= FALSE 
            {
              Boolean RESULT =null;
		 RESULT = false; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // boolexpr ::= boolexpr AND boolexpr 
            {
              Boolean RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Boolean l = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Boolean r = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = l && r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // boolexpr ::= boolexpr OR boolexpr 
            {
              Boolean RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Boolean l = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Boolean r = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = l || r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // boolexpr ::= NOT boolexpr 
            {
              Boolean RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = !b; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // boolexpr ::= ISFIRST 
            {
              Boolean RESULT =null;
		 RESULT = parser.isFirst(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // boolexpr ::= ISLAST 
            {
              Boolean RESULT =null;
		 RESULT = parser.isLast(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // boolexpr ::= PARENT IS classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (boolean) (parser.checkParent(c, true, false)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // boolexpr ::= PARENT LIKE classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (boolean) (parser.checkParent(c, false, false)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // boolexpr ::= PARENT ALLOWS STANDALONE 
            {
              Boolean RESULT =null;
		 RESULT = ((ActorHandler) parser.getParent()).getActorHandlerInfo().canContainStandalones(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // boolexpr ::= PARENT ALLOWS SOURCE 
            {
              Boolean RESULT =null;
		 RESULT = ((ActorHandler) parser.getParent()).getActorHandlerInfo().canContainSource(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // boolexpr ::= ANYPARENT IS classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (boolean) (parser.checkParent(c, true, true)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // boolexpr ::= ANYPARENT LIKE classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (boolean) (parser.checkParent(c, false, true)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // boolexpr ::= PRECEDING GENERATES classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.precedingGenerates(c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // boolexpr ::= FOLLOWING ACCEPTS classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.followingAccepts(c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // boolexpr ::= BEFORE STANDALONE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isStandalone(true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // boolexpr ::= BEFORE SOURCE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSource(true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // boolexpr ::= BEFORE TRANSFORMER 
            {
              Boolean RESULT =null;
		 RESULT = parser.isTransformer(true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // boolexpr ::= BEFORE SINK 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSink(true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // boolexpr ::= BEFORE classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.isClassname(true, c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // boolexpr ::= AFTER STANDALONE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isStandalone(false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // boolexpr ::= AFTER SOURCE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSource(false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // boolexpr ::= AFTER TRANSFORMER 
            {
              Boolean RESULT =null;
		 RESULT = parser.isTransformer(false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // boolexpr ::= AFTER SINK 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSink(false); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // boolexpr ::= AFTER classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.isClassname(false, c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // boolexpr ::= THIS IS classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.isClassname(0, c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // boolexpr ::= THIS IS STANDALONE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isStandalone(0); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // boolexpr ::= THIS IS SOURCE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSource(0); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // boolexpr ::= THIS IS TRANSFORMER 
            {
              Boolean RESULT =null;
		 RESULT = parser.isTransformer(0); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // boolexpr ::= THIS IS SINK 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSink(0); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // boolexpr ::= FIRST IS classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.isClassname(-1, c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // boolexpr ::= FIRST IS STANDALONE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isStandalone(-1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // boolexpr ::= FIRST IS SOURCE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSource(-1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // boolexpr ::= FIRST IS TRANSFORMER 
            {
              Boolean RESULT =null;
		 RESULT = parser.isTransformer(-1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // boolexpr ::= FIRST IS SINK 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSink(-1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // boolexpr ::= LAST IS classexpr 
            {
              Boolean RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = parser.isClassname(1, c); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // boolexpr ::= LAST IS STANDALONE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isStandalone(1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // boolexpr ::= LAST IS SOURCE 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSource(1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // boolexpr ::= LAST IS TRANSFORMER 
            {
              Boolean RESULT =null;
		 RESULT = parser.isTransformer(1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // boolexpr ::= LAST IS SINK 
            {
              Boolean RESULT =null;
		 RESULT = parser.isSink(1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolexpr",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // classexpr ::= CLASSNAME 
            {
              String RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("classexpr",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // cmdexpr ::= CLASSNAME 
            {
              String RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cmdexpr",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // cmdexpr ::= CMDLINE 
            {
              String RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cmdexpr",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
