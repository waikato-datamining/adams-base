/*
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * SizeOf.java
 * Copyright (C) 2009-2024 University of Waikato, Hamilton, New Zealand
 */

package adams.core;

import adams.core.logging.LoggingHelper;
import sizeof.agent.Filter;
import sizeof.agent.Statistics;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;

/**
 * Helper class for measuring the size of objects using 
 * <a href="http://www.jroller.com/maxim/entry/again_about_determining_size_of" target="_blank">Maxim Zakharenkov's SizeOf agent</a>
 * or simply the length of the byte array generated by serialization.
 *
 * @author  fracpete (fracpete at waikato dot ac dot nz)
 */
public class SizeOf {

  /** the class to use. */
  public final static String CLASS_SIZEOF = "sizeof.agent.SizeOfAgent";

  /** the method to use. */
  public final static String METHOD_FULLSIZEOF = "fullSizeOf";

  /** the method to use (per class). */
  public final static String METHOD_FULLSIZEPERCLASS = "fullSizePerClass";

  /** whether the SizeOf agent is available. */
  protected static Boolean m_Available;

  /** the SizeOf agent class. */
  protected static Class m_Class;

  /** the SizeOf agent method to use. */
  protected static Method m_FullSizeOf;

  /** the SizeOf agent method to use (with filter). */
  protected static Method m_FullSizeOfFilter;

  /** the SizeOf agent method to use (per class). */
  protected static Method m_FullSizePerClass;

  /** the SizeOf agent method to use (per class, with filter). */
  protected static Method m_FullSizePerClassFilter;

  /**
   * Returns whether the SizeOf agent is available or not.
   *
   * @return		true if agent available
   */
  public static synchronized boolean isSizeOfAgentAvailable() {
    Long	size;
    
    if (m_Available == null) {
      try {
	m_Class            = Class.forName(CLASS_SIZEOF);
	m_FullSizeOf       = m_Class.getMethod(METHOD_FULLSIZEOF, Object.class);
	m_FullSizeOfFilter = m_Class.getMethod(METHOD_FULLSIZEOF, Object.class, Filter.class);
	m_FullSizePerClass = m_Class.getMethod(METHOD_FULLSIZEPERCLASS, Object.class);
	m_FullSizePerClassFilter = m_Class.getMethod(METHOD_FULLSIZEPERCLASS, Object.class, Filter.class);
      }
      catch (Exception e) {
	m_Class            = null;
	m_FullSizeOf       = null;
	m_FullSizeOfFilter = null;
	m_FullSizePerClass = null;
	m_FullSizePerClassFilter = null;
	m_Available        = false;
	System.err.println("SizeOf agent not on classpath available!");
      }
      
      if (m_Class != null) {
	try {
	  size        = (Long) m_FullSizeOf.invoke(null, new Object[]{1});
	  m_Available = (size > 0);
	}
	catch (Exception e) {
	  LoggingHelper.global().log(Level.SEVERE, "SizeOf agent not available! Use '-javaagent:sizeofag.jar' on commandline.", e);
	  m_Available = false;
	}
      }
    }

    return m_Available;
  }

  /**
   * Returns the size of an object.
   *
   * @param obj		the object to measure
   * @return		the size or -1 if failed to determine
   * @see		#sizeOfAgent(Object)
   * @see		#sizeOfSerialization(Object)
   */
  public static int sizeOf(Object obj) {
    int		result;

    result = sizeOfAgent(obj);
    if (result == -1)
      result = sizeOfSerialization(obj);

    return result;
  }

  /**
   * Returns the size of an object.
   *
   * @param obj		the object to measure
   * @param filter 	for filtering objects/fields
   * @return		the size or -1 if failed to determine
   * @see		#sizeOfAgent(Object, Filter)
   * @see		#sizeOfSerialization(Object)
   */
  public static int sizeOf(Object obj, Filter filter) {
    int		result;

    result = sizeOfAgent(obj, filter);
    if (result == -1)
      result = sizeOfSerialization(obj);

    return result;
  }

  /**
   * Returns the size of an object using the agent.
   *
   * @param obj		the object to measure
   * @return		the size or -1 if agent not available
   */
  public static int sizeOfAgent(Object obj) {
    Long	result;
    
    result = -1L;
    if (isSizeOfAgentAvailable()) {
      try {
	result = (Long) m_FullSizeOf.invoke(null, obj);
      }
      catch (Exception e) {
	result = -1L;
      }
    }
    
    return result.intValue();
  }

  /**
   * Returns the size of an object using the agent.
   *
   * @param obj		the object to measure
   * @param filter 	for filtering objects/fields
   * @return		the size or -1 if agent not available
   */
  public static int sizeOfAgent(Object obj, Filter filter) {
    Long	result;

    result = -1L;
    if (isSizeOfAgentAvailable()) {
      try {
	result = (Long) m_FullSizeOfFilter.invoke(null, obj, filter);
      }
      catch (Exception e) {
	result = -1L;
      }
    }

    return result.intValue();
  }

  /**
   * Returns the size and number of instances broken down by class for the
   * given object.
   *
   * @param obj		the object to inspect
   * @return		empty map if not available, otherwise the statistics per class
   */
  public static Map<Class,Statistics> sizeOfAgentPerClass(Object obj) {
    Map<Class,Statistics>	result;

    result = new HashMap<>();
    if (isSizeOfAgentAvailable()) {
      try {
	result = (Map<Class,Statistics>) m_FullSizePerClass.invoke(null, obj);
      }
      catch (Exception e) {
	result = new HashMap<>();
      }
    }

    return result;
  }

  /**
   * Returns the size and number of instances broken down by class for the
   * given object.
   *
   * @param obj		the object to inspect
   * @param filter 	for filtering objects/fields
   * @return		empty map if not available, otherwise the statistics per class
   */
  public static Map<Class,Statistics> sizeOfAgentPerClass(Object obj, Filter filter) {
    Map<Class,Statistics>	result;

    result = new HashMap<>();
    if (isSizeOfAgentAvailable()) {
      try {
	result = (Map<Class,Statistics>) m_FullSizePerClassFilter.invoke(null, obj, filter);
      }
      catch (Exception e) {
	result = new HashMap<>();
      }
    }

    return result;
  }

  /**
   * Returns the size of an object using serialization.
   *
   * @param obj		the object to measure
   * @return		the size or -1 if not serializable
   */
  public static int sizeOfSerialization(Object obj) {
    int		result;

    try {
      result = SerializationHelper.toByteArray(obj).length;
    }
    catch (Exception e) {
      result = -1;
    }

    return result;
  }

  /**
   * For testing only.
   *
   * @param args	ignored
   */
  public static void main(String[] args) {
    System.out.println(sizeOfAgent(args));
    System.out.println(sizeOfAgent(1));
    System.out.println(sizeOfAgent(1.0));
    System.out.println(sizeOfAgent(new DateFormat("yyyy-MM-dd")));
    System.out.println(sizeOf(args));
    System.out.println(sizeOf(1));
    System.out.println(sizeOf(1.0));
    System.out.println(sizeOf(new DateFormat("yyyy-MM-dd")));
  }
}
